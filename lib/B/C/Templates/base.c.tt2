/* [% creator %] */

[% IF debug.benchmark -%]
#define DEBUG_BENCHMARK 1
[% END -%]

#define PERL_CORE /* Needed for some extensions perl core refeses to export (win32 only)*/
#include "EXTERN.h" /* Embedded interface */
#include "perl.h"   /* API interface */
#include "XSUB.h"   /* XS interface */

#ifdef DEBUG_BENCHMARK
#include <sys/time.h>

struct timespec start, end;
uint64_t delta_us;
PerlIO * PIO_stdout;

#define benchmark_time(msg) clock_gettime(CLOCK_MONOTONIC_RAW, &end); delta_us = (end.tv_sec - start.tv_sec) * 1000000000 + (end.tv_nsec - start.tv_nsec); PerlIO_printf(PIO_stdout, "--USECONDS %lu == %s\n", delta_us, msg )
#else
#define benchmark_time(msg)
#endif /* end of DEBUG_BENCHMARK */

/* Workaround for mapstart: the only op which needs a different ppaddr */
#undef Perl_pp_mapstart
#define Perl_pp_mapstart Perl_pp_grepstart
#undef OP_MAPSTART
#define OP_MAPSTART OP_GREPSTART



#ifdef BROKEN_STATIC_REDECL
#define Static extern
#else
#define Static static
#endif /* BROKEN_STATIC_REDECL */

/* TODO: Why was this removed from perl core? */
/* No longer available when C<PERL_CORE> is defined. */
#ifndef Nullsv
#  define Null(type) ((type)NULL)
#  define Nullsv Null(SV*)
#  define Nullhv Null(HV*)
#  define Nullgv Null(GV*)
#  define Nullop Null(OP*)
#endif
#ifndef GV_NOTQUAL
#  define GV_NOTQUAL 0
#endif

typedef struct shared_he SHARED_HE;

/* these bc_*bodyless* macros are just using an extra parens around sv, should patch perl */
#define BODYLESS_IV_PTR(sv) \
    ((char*)sv)+STRUCT_OFFSET(struct STRUCT_SV, sv_u) - STRUCT_OFFSET(XPVIV, xiv_iv)

#define BODYLESS_UV_PTR(sv) \
    ((char*)sv)+STRUCT_OFFSET(struct STRUCT_SV, sv_u) - STRUCT_OFFSET(XPVUV, xuv_uv)


#define IMMORTAL_PL_strtab 0x7ffffff

static int fast_perl_destruct( PerlInterpreter *my_perl );
static void my_curse( pTHX_ SV* const sv );

/* perl.c prototypes we do locally here now. */
static int bc_perl_parse(pTHXx_ XSINIT_t xsinit, int argc, char **argv, char **env);
static void bc_parse_body(char **env, XSINIT_t xsinit);
static void bc_init_postdump_symbols(pTHX_ int argc, char **argv, char **env);
static void bc_init_predump_symbols(pTHX);

/* TODO: Not provided in perl core? */
#ifndef dVAR
# ifdef PERL_GLOBAL_STRUCT
#  define dVAR		pVAR    = (struct perl_vars*)PERL_GET_VARS()
# else
#  define dVAR		dNOOP
# endif
#endif

[%# Add static modules like " Win32CORE". This data comes from $Config{static_ext} %]
[% FOREACH xsub IN stashxsubs %]
EXTERN_C void boot_[% xsub %] (pTHX_ CV* cv);
[% END %]

/************************************************************************************************************
*
*       Static shared HE
*
*************************************************************************************************************/

/* get a HEK* from a shared_he */
//      (HEK*) ( (void*) &sHe + 3 * sizeof(void*) )
// or maybe
//      (HEK*) &(( (SHARED_HE*) &sHe)->shared_he_hek);"

#define get_sHe_HEK(sHe) (HEK*) ( (void*) &sHe + 3 * sizeof(void*) )

/* macro to ceate the struct (can be protected in C to define it once) */
#define DEFINE_STATIC_SHARED_HE_STRUCT(len) \
    struct _sHeS_##len { HE *hent_next; HEK *hent_hek; union { SV *hent_val;  Size_t hent_refcount; } he_valu;  U32 hek_hash;  I32 hek_len;  char hek_key[ len + 1]; char flags; };

/* macro to create our sHe */
#define ALLOC_sHe(index, klen, key_string, flags_byte) \
    static struct _sHeS_##klen sHe##index = { NULL, NULL, { .hent_refcount = IMMORTAL_PL_strtab }, 0, klen, key_string, flags_byte  };

/* declare all our shared_HE struct [ once per size ] */
[% section.sharedhestructs.output( "%s\n" ) %]

/* sharedhe definitions using the ALLOC_sHe macro */
[% section.sharedhe.output( "%s\n" ) %]

Static SHARED_HE* sharedhe_list[[% section.sharedhe.index + 1 %]] =  {
[%- FOREACH num IN [ 0 .. section.sharedhe.index ] %]
    (SHARED_HE*) &sHe[% num %], /* sharedhe_list[[%num%]] */
[%- END %]
};

/************************************************************************************************************
*
*       output_all()
*
*************************************************************************************************************/

[% section.sym.output( "#define %s\n" ) %]

/*  output_declarations() called by output_all() */

#define UNUSED 0
#define sym_0 0

PERL_STATIC_INLINE HEK *
my_share_hek( pTHX_ const char *str, I32 len, register U32 hash );
#undef share_hek
#define share_hek(str, len, hash) my_share_hek( aTHX_ str, len, hash );

struct my_padname_with_str {
    char *     xpadn_pv;
    HV *       xpadn_ourstash;
    union {
       HV *    xpadn_typestash;
       CV *    xpadn_protocv;
    } xpadn_type_u;
    U32        xpadn_low;
    U32        xpadn_high;
    U32        xpadn_refcnt;
    int        xpadn_gen;
    U8         xpadn_len;
    U8         xpadn_flags;
    char       xpadn_str[ [% MAX_PADNAME_LENGTH %] ];
};

/* Missing type defs in perl so we'll make our own. */
typedef struct my_padname_with_str MyPADNAME;

typedef struct { U32 a; U32 b; }      ASSIGN_HEKKEY2PV;

/* extra typedef */
[% section.typedef.output( "%s\n" ) %]

/*
    Tricky hack for -fcog since 5.10 on !c99 compilers required. We need a char* as
    *first* sv_u element to be able to statically initialize it. A int does not allow it.
    gcc error: initializer element is not computable at load time
    We introduce a SVPV as SV.
    In core since 5.12
*/

typedef struct p5rx RE;
Static IV PL_sv_objcount = 0; /* deprecated with 5.21.1 but still needed and used */
SV* sv;
[% IF gv_index %]
Static GV *dynamic_gv_list[[% gv_index %]];
[% END %]

/* back in output_all() */

/* define all Static sections */
[% FOREACH sect IN section_list -%]
[% lines = section.$sect.index + 1 -%]
[% NEXT IF lines == 0 -%]
Static [% section.$sect.typename() %] [% section.$sect.name() %]_list[[% lines %]];
[% END -%]

/* hack for when Perl accesses PVX of GVs */
Static const char emptystring[] = "\0";

/* newXS for core XS needs a filename */
Static const char xsfile[] = "universal.c";

#define ptr_undef NULL
#undef CopFILE_set
#define CopFILE_set(c,pv)  CopFILEGV_set((c), gv_fetchfile(pv))

[% IF init2_remap.size and !HAVE_DLFCN_DLOPEN %]
XS(XS_DynaLoader_dl_load_file);
XS(XS_DynaLoader_dl_find_symbol);
[% END %]

/************************************************************************************************************
*
*       start COWPVs
*
*************************************************************************************************************/

[% section.cowpv.output( "%s\n" ) %]
/* end COWPVs */

/* <const.output> */
[% section.const.output( "%s\n" ) %]
/* </const.output> */

static void declare_static_sections() { /* declare our static section 'blocks' to perl */
/* TODO: move sv_list first and other (gv_list) most common structs as order matters ! */
/* CV, magic, and then anything else */
[% FOREACH sect IN section_list -%]
[% lines = section.$sect.index + 1 -%]
[% SET sname = section.$sect.name() -%]
[% SET lname = "${sname}_list" -%]
[% NEXT IF lines == 0 -%]
    declare_static_memory( &[% lname %][0], &[% lname %][[% section.$sect.index %]], sizeof([% lname %][0]) );
[% END -%]

[% IF section.cowpv.index >= 0 -%]
    declare_static_memory( allCOWPVs, ( (char*) allCOWPVs + sizeof(allCOWPVs) ), 0 /* we do not know - breaks re-alloc */ );
[% END -%]

}

/* <decl.output> */
[% section.decl.output( "%s\n" ) %]
/* </decl.output> */

static void HvSETUP(HV* hv, U32 size) {
    char *array;
    /* malloc the hash array + the xpvhv_aux which is part of it */
    Newxz (array, PERL_HV_ARRAY_ALLOC_BYTES (size) + sizeof(struct xpvhv_aux), char);

    /* setting the hash array to the HV (in sv_list) in sv_any */
    HvARRAY(hv) = (HE **) array;

    return;
}

static void HvAddEntry(HV* hv, SV* value, SHARED_HE* hek, I32 max) {
    HE **oentry;
    HE *entry;

    entry            = (HE*) safemalloc(sizeof(HE));
    HeKEY_hek(entry) = &(hek->shared_he_hek);
    HeVAL (entry)    = value;
    oentry           = &(HvARRAY (hv))[HEK_HASH(&(hek->shared_he_hek)) & max];
    HeNEXT(entry)    = *oentry;
    *oentry          = entry;

    return;
}

[% IF devel_peek_needed %]
static void
S_do_dump(pTHX_ SV *const sv, I32 lim)
{
    dVAR;
    SV *pv_lim_sv = get_sv("Devel::Peek::pv_limit", 0);
    const STRLEN pv_lim = pv_lim_sv ? SvIV(pv_lim_sv) : 0;
    SV *dumpop = get_sv("Devel::Peek::dump_ops", 0);
    const U16 save_dumpindent = PL_dumpindent;
    PL_dumpindent = 2;
    do_sv_dump(0, Perl_debug_log, sv, 0, lim,
	       (bool)(dumpop && SvTRUE(dumpop)), pv_lim);
    PL_dumpindent = save_dumpindent;
}
static OP *
S_pp_dump(pTHX)
{
    dSP;
    const I32 lim = PL_op->op_private == 2 ? (I32)POPi : 4;
    dPOPss;
    S_do_dump(aTHX_ sv, lim);
    RETPUSHUNDEF;
}
[% END %]

/*
    cop_list - array of cops in the code. for debugging, line number info. State/Context op. "Every ; is a cop."
    op_list  - Chain of operations
    unop_list - Unary operations
    binop_list - Binary argument operation: first/last aren't useful to runtime but might be introspected by certain modules.
    listop_list - Op chains run.c
    svop_list - all scalars
    xpv_list - Additional DATA for SVs ( PV body )
    xpvav_list - Additional data for arrays
    xpvhv_list - Additional data for hashes
    xpviv_list - Additional data for PVIV
    xpvnv_list - Additional data for PVNV
    xpvmg_list - magic
    xpvio_list - iosect - initial state of all file handles
*/

[% FOREACH sect IN section_list %]
[% lines = section.$sect.index + 1 %]
[% NEXT IF lines == 0 %]
Static [% section.$sect.typename() %] [% section.$sect.name() %]_list[[% lines %]] = {
[% section.$sect.output("    { %s }, /* %s_list[%d] %s %s */\n") %]
};


[% END %]

/* handy helpers for B::C */

SV ** INITAv(AV * av, int number_of_items) {
    SV **svp;

    Newx(svp, number_of_items, SV*);
    AvALLOC(av) = svp;
    AvARRAY(av) = svp;
    return svp;
}

PADNAME ** INITPADNAME(PADNAMELIST *padname, int number_of_items) {
    PADNAME **svp;
    PADNAMELIST *padnl = padname;
    Newxz(svp, number_of_items, PADNAME *);
    PadnamelistARRAY(padnl) = svp;
    return svp;
}

PAD ** INITPADLIST(PADLIST *pad, int number_of_items) {
    PAD **svp;
    PADLIST *padl = pad;
    Newxz(svp, number_of_items, PAD *);
    PadlistARRAY(padl) = svp;
    return svp;
}

/* end of handy helpers */


[% section.init_stash.output( "    %s\n", 'perl_init_stash' ) %]

[% section.init_static_assignments.output( "    %s\n", 'perl_init_static_assignments' ) %]

[% section.init_vtables.output( "    %s\n", 'perl_init_vtables' ) %]

[% section.init_COREbootstraplink.output( "    %s\n", 'perl_init_COREbootstraplink' ) %]
[% section.init_bootstraplink.output( "    %s\n", 'perl_init_bootstraplink' ) %]

#define SIG_SIZE [% Config.sig_size %]

void setup_perl_globals() {
    PL_defstash = [% PL.defstash %];       /*  SVt_PVHV */
    PL_curstname = [% PL.curstname %];     /* "main" SVt_PV */
    PL_incgv = [% PL.incgv %];             /* *main::INC SVt_PVGV hv and AV must be set! */
    PL_hintgv = [% PL.hintgv %];           /* *main::^H SVt_PVGV */
    PL_defgv = [% PL.defgv %];             /* *main::_ SVt_PVGV must have SV and AV setup?? */
    PL_errgv = [% PL.errgv %];             /* *main::@ SVt_PVGV  must have SV setup */
    PL_replgv = [% PL.replgv %];           /* *main::^R SVt_PVGV */
    PL_debstash = [% PL.debstash %];       /* *main::DB:: SVt_PVHV */
    PL_globalstash = [% PL.globalstash %]; /* *main::CORE::GLOBAL:: SVt_PVHV */

    /* initialize signals - view Perl_magic_setsig and Perl_whichsig_pvn for usage */
    Newxz(PL_psig_name, 2 * SIG_SIZE, SV*);
    Newxz(PL_psig_pend, SIG_SIZE, int);
    PL_psig_ptr = PL_psig_name + SIG_SIZE;

}

static void init_pl_strtab(pTHX) {
/* only init PL_strtab if we have content for it */
[% IF section.sharedhe.index + 1 > 0 %]

    if (PL_hash_seed_set == FALSE) {
        Perl_get_hash_seed(aTHX_ PL_hash_seed);
        PL_hash_seed_set= TRUE;
    }

    PL_strtab = newHV();

    /* manual malloc */
    //char * array;
    //Newxz (array, PERL_HV_ARRAY_ALLOC_BYTES ([% PL_strtab_max %]) + sizeof(struct xpvhv_aux), char);
    //HvARRAY (PL_strtab) = (HE **) array;

    /* automatic malloc */
    hv_ksplit(PL_strtab, [% PL_strtab_max %]);
    HvSHAREKEYS_off(PL_strtab);                        /* mandatory */
    //SvOOK_on(PL_strtab);

    {
        int i;
        HE   *entry;
        HE  **oentry;
        HEK  *hek_struct;

        //HvMAX(PL_strtab) = [% PL_strtab_max - 1 %];
        HvTOTALKEYS(PL_strtab) = [% section.sharedhe.index + 1 %];
        SvREFCNT(PL_strtab) = 99999;

        for (i=0; i < [% section.sharedhe.index + 1 %]; i++) {
            entry = &(sharedhe_list[i]->shared_he_he);
            hek_struct = &(sharedhe_list[i]->shared_he_hek);

            HeKEY_hek(entry) = hek_struct;
            PERL_HASH (HEK_HASH(hek_struct), HEK_KEY(hek_struct), HEK_LEN(hek_struct));

            /* Insert the hes */
            oentry = &(HvARRAY (PL_strtab))[HEK_HASH(hek_struct) & (I32) [% PL_strtab_max - 1 %]  ];
            HeNEXT(entry) = *oentry;
            *oentry = entry;
        }
    }

[% END %]
}

static void init_assign(pTHX) {
[% IF section.assign_hekkey2pv.index + 1 > 0 %]
    U32 i;

    for (i=0; i < [% section.assign_hekkey2pv.index + 1 %]; i++) {
        sv_list[assign_hekkey2pv_list[i].a].sv_u.svu_pv = sharedhe_list[assign_hekkey2pv_list[i].b]->shared_he_hek.hek_key;
    }
[% END %]
}

static void perl_init0(pTHX) { /* fixup_ppaddr */
[% section.init0.output( "    %s\n" ) %]
};


[% section.init.output( "    %s\n", init_name ) %]

/* deferred init1 of regexp */
[% section.init1.output( "    %s\n", "perl_init1" ) %]

/* deferred init of XS/Dyna loaded modules */

[% section.init2.output( "    %s\n", 'perl_init2' ) %]

/*
    COMPILE STATS:  [% compile_stats %]
     NULLOP count:  [% nullop_count %]
*/

/************************************************************************************************************
*
*       output_main_rest()
*
*************************************************************************************************************/

/* The first assignment got already refcount bumped */
PERL_STATIC_INLINE HEK *
my_share_hek( pTHX_ const char *str, I32 len, register U32 hash ) {
    if (!hash) {
      PERL_HASH(hash, str, abs(len));
    }
    return share_hek_hek(Perl_share_hek(aTHX_ str, len, hash));
}

static void
my_curse( pTHX_ SV* const sv ) {
    dSP;
    dVAR;
    HV* stash;
    bool reset_stash;

    assert(SvOBJECT(sv));
    do {
        reset_stash = FALSE;
        stash = SvSTASH(sv);
        assert(SvTYPE(stash) == SVt_PVHV);
	if (HvNAME(stash)) {
	    CV* destructor = NULL;
	    if (!SvOBJECT(stash))
            destructor = (CV *)SvSTASH(stash);
	    if ( !destructor || HvMROMETA(stash)->destroy_gen != PL_sub_generation ) {
            bool autoload = FALSE;
            GV * gv = gv_fetchmeth_pvn(stash, "DESTROY", 7, -1, 0);
            if (gv) destructor = GvCV(gv);
            if ( !destructor ) {
                gv = gv_autoload_pvn(stash, "DESTROY", 7, GV_AUTOLOAD_ISMETHOD);
                if (gv) destructor = GvCV(gv);
                if (destructor) autoload = TRUE;
            }

            if ( gv ) {
                if (!SvOBJECT(stash)) {
                    if ( !autoload ) {
                        SvSTASH(stash) = destructor ? (HV *)destructor : ((HV *)0)+1;
                        HvAUX(stash)->xhv_mro_meta->destroy_gen = PL_sub_generation;
                        reset_stash = TRUE;
                    }
                }
            }
	    }
	    assert(!destructor || destructor == ((CV *)0)+1
		   || SvTYPE(destructor) == SVt_PVCV);
	    if (destructor && destructor != ((CV *)0)+1
		/* A constant subroutine can have no side effects, so
		   don't bother calling it.  */
		&& !CvCONST(destructor)
		/* Don't bother calling an empty destructor or one that
		   returns immediately. */
		&& (CvISXSUB(destructor)
		|| (CvSTART(destructor)
		    && (CvSTART(destructor)->op_next->op_type != OP_LEAVESUB)
		    && (CvSTART(destructor)->op_next->op_type != OP_PUSHMARK
			|| CvSTART(destructor)->op_next->op_next->op_type != OP_RETURN
		       )
		   ))
	       )
	    {
		SV* const tmpref = newRV(sv);
		DEBUG_D(PerlIO_printf(Perl_debug_log, "Calling %s::DESTROY\n", HvNAME(stash)));
		SvREADONLY_on(tmpref); /* DESTROY() could be naughty */
		ENTER;
		PUSHSTACKi(PERLSI_DESTROY);
		EXTEND(SP, 2);
		PUSHMARK(SP);
		PUSHs(tmpref);
		PUTBACK;
		call_sv((SV*)destructor, G_DISCARD|G_EVAL|G_KEEPERR|G_VOID);
		POPSTACK;
		SPAGAIN;
		LEAVE;
        /*(void)hv_deletehek(PL_stashcache, HvNAME_HEK(hv), G_DISCARD);*/
		if(SvREFCNT(tmpref) < 2) {
		    /* tmpref is not kept alive! */
		    SvREFCNT(sv)--;
		    SvRV_set(tmpref, NULL);
		    SvROK_off(tmpref);
		}
		SvREFCNT_dec(tmpref);
	    }

        if ( reset_stash == true ) {
            SvSTASH(stash) = (HV*) 0;
        }

	}
    } while (SvOBJECT(sv) && SvSTASH(sv) != stash);

    if (SvOBJECT(sv)) {
	/* Curse before freeing the stash, as freeing the stash could cause
	   a recursive call into S_curse. */
	SvOBJECT_off(sv);	/* Curse the object. */
	SvSTASH_set(sv,0);	/* SvREFCNT_dec may try to read this */
    }
}

static int fast_perl_destruct( PerlInterpreter *my_perl ) {
    dVAR;
#ifdef DEBUGGING
    VOL signed char destruct_level;  /* see possible values in intrpvar.h */
#endif

    PERL_UNUSED_ARG(my_perl);

    assert(PL_scopestack_ix == 1);

    /* wait for all pseudo-forked children to finish */
    PERL_WAIT_FOR_CHILDREN;

#ifdef DEBUGGING
    destruct_level = PL_perl_destruct_level;
    {
	const char * const s = PerlEnv_getenv("PERL_DESTRUCT_LEVEL");
	if (s) {
            const int i = atoi(s);
	    if (destruct_level < i) destruct_level = i;
#ifdef PERL_TRACK_MEMPOOL
            /* RT #114496, for perl_free */
            PL_perl_destruct_level = i;
#endif
	}
    }
#endif

    if (PL_exit_flags & PERL_EXIT_DESTRUCT_END) {
        dJMPENV;
        int x;
        JMPENV_PUSH(x);
        if (PL_endav && !PL_minus_c) {
            PL_phase = PERL_PHASE_END;
            call_list(PL_scopestack_ix, PL_endav);
        }
        PERL_UNUSED_ARG(x);
        JMPENV_POP;
    }
    LEAVE;
    FREETMPS;
    assert(PL_scopestack_ix == 0);

    /* Need to flush since END blocks can produce output */
    my_fflush_all();

    PL_main_start = NULL;
    PL_main_cv = NULL;
    PL_curcop = &PL_compiling;
    PL_phase = PERL_PHASE_DESTRUCT;

    if (PL_threadhook(aTHX)) {
        /* Threads hook has vetoed further cleanup */
	PL_veto_cleanup = TRUE;
        return STATUS_EXIT;
    }
    PerlIO_destruct(aTHX);

    /* B::C -O3 specific: first curse (i.e. call DESTROY) all our static SVs */
    if (PL_sv_objcount) {
        int i = 1;
        DEBUG_D(PerlIO_printf(Perl_debug_log, "\nCursing named global static sv_arena:\n"));
        PL_in_clean_all = 1;
        for (; i < SvREFCNT(&sv_list[0]); i++) { /* loop on all our SVs: probably want to use the value from TT section.sv_sect.index + 1 */
            SV *sv = &sv_list[i];
            if (SvREFCNT(sv)) {
                if (SvTYPE(sv) == SVt_IV && SvROK(sv))
                    sv = SvRV(sv);
                if (sv && SvOBJECT(sv) && SvTYPE(sv) >= SVt_PVMG && SvSTASH(sv)
                    && SvTYPE(sv) != SVt_PVCV && SvTYPE(sv) != SVt_PVIO
                    && PL_defstash /* Still have a symbol table? */
                    && SvDESTROYABLE(sv))
                {
                    SvREFCNT(sv) = 0;
                    my_curse(aTHX_ sv);
                }
            }
        }
    }
    if (DEBUG_D_TEST) {
        SV* sva;
        PerlIO_printf(Perl_debug_log, "\n");
        for (sva = PL_sv_arenaroot; sva; sva = (SV*)SvANY(sva)) {
            PerlIO_printf(Perl_debug_log, "sv_arena: 0x%p - 0x%p (%lu)\n",
              sva, sva+SvREFCNT(sva), (long unsigned int) 0+SvREFCNT(sva));
        }
    }

    if (PL_sv_objcount) {
        PL_in_clean_all = 1;
        /* at this point the cache might point to some non existing GVs */
        /* clear the cache, as it's going to be rebuilt if needed */
        hv_clear(PL_stashcache);
        sv_clean_objs(); /* and now curse the rest */
        PL_sv_objcount = 0;
    }
    PL_warnhook = NULL;
    PL_diehook = NULL;
    /* call exit list functions */
    while (PL_exitlistlen-- > 0)
	PL_exitlist[PL_exitlistlen].fn(aTHX_ PL_exitlist[PL_exitlistlen].ptr);
    PL_exitlist = NULL;

#if defined(PERLIO_LAYERS)
    PerlIO_cleanup(aTHX);
#endif
    return 0;
}

#define XS_DynaLoader_boot_DynaLoader boot_DynaLoader
EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);

static void xs_init (pTHX);
static void dl_init (pTHX);

/* yanked from perl.c */
static void
xs_init(pTHX)
{
    char *file = __FILE__;
    dTARG;
    dSP;

    newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);

    SAVETMPS;
    targ=sv_newmortal();

    PUSHMARK(sp);
    XPUSHp("DynaLoader", 10);
    PUTBACK;
    boot_DynaLoader(aTHX_ get_cv("DynaLoader::bootstrap", GV_ADD));
    SPAGAIN;

    FREETMPS;
}


[% IF XS.has_xs() -%]
typedef void (*bootFunc)(pTHX_ CV* cv);
static void do_bootstrap(pTHX_ const char *name, int len, const char *bootstrap, bootFunc boot) {
    dTARG;
    PERL_UNUSED_ARG(targ);
    dSP;

    PUSHMARK(sp);
    /* XXX -O1 or -O2 needs XPUSHs with dynamic pv */
    mXPUSHp(name, len);

    /* XSLoader has the 2nd insanest API in whole Perl, right after make_warnings_object() */
    PUTBACK;
    /* CvSTASH(CvGV(cv)) is invalid without (issue 86) */
    /* TODO: utf8 stashname */
    { /* GH 333 */
        CV* cv = (CV*)SvREFCNT_inc_simple_NN(get_cv(bootstrap, GV_ADD));
        CvISXSUB_on(cv); /* otherwise a perl assertion fails. */
        cv->sv_any->xcv_padlist_u.xcv_hscxt = &PL_stack_sp; /* xs_handshake */
        boot(aTHX_ cv);
    }

    SPAGAIN;

    return;
}
[% END %]

/* EXTERN_C void boot_JSON__XS(pTHX_ CV* cv); */
[% FOREACH module IN XS.modules() -%]
EXTERN_C void boot_[% module.replace('::', '__') %](pTHX_ CV* cv);
[% END -%]

static void dl_init(pTHX)
{
    [% IF XS.has_xs() %]
    dTARG;
    PERL_UNUSED_ARG(targ);
    ENTER;
    SAVETMPS;

  [% FOREACH module IN XS.modules() -%]
  do_bootstrap( "[% module %]", [% module.length %], "[% module %]::bootstrap", &boot_[% module.replace('::', '__') %] );
  [% END -%]

    FREETMPS;
    LEAVE;
    [% END %]
}



/************************************************************************************************************
*
*       output_main()
*
*************************************************************************************************************/

/* if USE_IMPLICIT_SYS, we need a 'real' exit */
#if defined(exit)
#undef exit
#endif

PerlInterpreter BC_unthreaded_interpreter;

int
main(int argc, char **argv, char **env)
{
    int exitstatus;

    /* Assure the interpreter struct is zeroed out. */
    Zero(&BC_unthreaded_interpreter, 1, PerlInterpreter);

#ifdef DEBUG_BENCHMARK
    clock_gettime(CLOCK_MONOTONIC_RAW, &start);
#endif
    PERL_SYS_INIT3(&argc,&argv,&env);

    assert(PL_do_undump == 0);

    init_pl_strtab(); /* Initialize PL_Strtab on our own before perl gets to it in perl_alloc. This allows us to use immportal constant shared HEKs */
    setup_perl_globals();
    perl_init_stash(); /* Setup the stashes */
    perl_init_vtables(); /* assign runtime vtables to magic structs since they point to C functions */
    perl_init_static_assignments(); /* Setup the stashes */

    /* setup $0 on execution */
    CopFILE_set(&PL_compiling, argv[0]);

    /* Sets up all PL_## variables */
	perl_construct( &BC_unthreaded_interpreter );

	PL_perl_destruct_level = 0;

#ifdef DEBUG_BENCHMARK
    PIO_stdout =  PerlIO_stdout();
    benchmark_time("got stdio");
#endif
    PL_exit_flags |= PERL_EXIT_DESTRUCT_END;

/* perlmain.c sets PL_use_safe_putenv so we must do this
   here as well.

   See perl's INSTALL file under
   Environment access for more information. */

#ifndef PERL_USE_SAFE_PUTENV
    PL_use_safe_putenv = 0;
#endif /* PERL_USE_SAFE_PUTENV */

    benchmark_time("prenewx");

    declare_static_sections(); /* declare all our sections to perl */

    benchmark_time("pre bc_perl_parse");

  [% IF TAINT %]
    /* -T option was passed to B::C so we need to do the same here. bc_perl_parse doesn't parse perl args now. */
    TAINTING_set(TRUE);
    TAINT_WARN_set(FALSE);
  [% END %]

    PL_curstash = PL_defstash;

    exitstatus = bc_perl_parse(&BC_unthreaded_interpreter, xs_init, argc, argv, env);
    benchmark_time("post bc_perl_parse");
    if (exitstatus)
       	exit( exitstatus );

    /* link the CORE CVs to the bootstrapped ones loaded by perl_parse  -- maybe xs_init ?? */
    perl_init_COREbootstraplink( aTHX );

    TAINT;

    benchmark_time("pre global setup");

    [% IF global_vars.dollar_caret_H %]
    PL_hints = [% global_vars.dollar_caret_H %];
    [% END %]

    [% IF global_vars.dollar_caret_UNICODE %]
    PL_unicode = [% global_vars.dollar_caret_UNICODE %];
    [% END %]

    sv_setpv_mg(get_sv("\030", GV_ADD|GV_NOTQUAL), [% global_vars.dollar_caret_X %]); /* $^X - EXECUTABLE_NAME */

    TAINT_NOT;

    /* PL_compcv used during compilation. */
    PL_compcv = MUTABLE_CV(newSV_type(SVt_PVCV));
    CvUNIQUE_on(PL_compcv);
    CvPADLIST(PL_compcv) = pad_new(0);

    /* our special compiled init */
    benchmark_time("init_assign");
    init_assign(aTHX);

    benchmark_time("preinit");
    perl_init(aTHX);

    benchmark_time("init1 pre");
    perl_init1(aTHX);
    benchmark_time("init1 done");

    /* load the XS modules */
    dl_init(aTHX);

    /* link the CVs to the bootstrapped ones */
    perl_init_bootstraplink( aTHX );

    CopSTASH_set(&PL_compiling, PL_defstash);

    /* We need to output evals after dl_init, in init2  */
    [% FOREACH eval_pv IN all_eval_pvs %]
    [% eval_pv %]
    [% END %]
    benchmark_time("evals completed.");

    perl_init2(aTHX);
    benchmark_time("init2 done.");

    exitstatus = perl_run( &BC_unthreaded_interpreter );
    benchmark_time("program complete");

    /* init pre_destruct */
    [% FOREACH str IN section.init.pre_destruct() %]
    [% str %]
    [% END %]
    benchmark_time("pre_destruct() done");

    /* destruct */

    fast_perl_destruct( &BC_unthreaded_interpreter );

    /*  XXX endav is called via call_list and so it is freed right after usage. Setting dirty here is useless */

    PERL_SYS_TERM();

    exit( exitstatus );
}

/* Through an interative process, perl_parse has been lifted from perl.c and re-factored to only support the
   things that make sense for a B::C run program. This simplifies and hopefully shortens startup. This code
   is only supportable via a static HV approach to B::C
   
   The following functions are now local to this templated B::C program.

       static int bc_perl_parse(pTHXx_ XSINIT_t xsinit, int argc, char **argv, char **env)
       static void bc_parse_body(char **env, XSINIT_t xsinit);
       static void bc_init_postdump_symbols(pTHX_ int argc, char **argv, char **env);
       static void bc_init_predump_symbols(pTHX);
*/

static int bc_perl_parse(pTHXx_ XSINIT_t xsinit, int argc, char **argv, char **env)
{
    dVAR;
    int ret;
    dJMPENV;

    PERL_ARGS_ASSERT_PERL_PARSE;
    PERL_UNUSED_ARG(my_perl);

    PL_origargc = argc;
    PL_origargv = argv;

    /* START: Determine how long $0 is allowed to be */
    /* Set PL_origalen be the sum of the contiguous argv[]
     * elements plus the size of the env in case that it is
     * contiguous with the argv[].  This is used in mg.c:Perl_magic_set()
     * as the maximum modifiable length of $0.  In the worst case
     * the area we are able to modify is limited to the size of
     * the original argv[0].  (See below for 'contiguous', though.)
     * --jhi */
    const char *s = NULL;
    int i;
    const UV mask = ~(UV)(PTRSIZE-1);

    /* Do the mask check only if the args seem like aligned. */
    const UV aligned = (mask < ~(UV)0) && ((PTR2UV(argv[0]) & mask) == PTR2UV(argv[0]));

     /* See if all the arguments are contiguous in memory.  Note
      * that 'contiguous' is a loose term because some platforms
      * align the argv[] and the envp[].  If the arguments look
      * like non-aligned, assume that they are 'strictly' or
      * 'traditionally' contiguous.  If the arguments look like
      * aligned, we just check that they are within aligned
      * PTRSIZE bytes.  As long as no system has something bizarre
      * like the argv[] interleaved with some other data, we are
      * fine.  (Did I just evoke Murphy's Law?)  --jhi */
    if (PL_origargv && PL_origargc >= 1 && (s = PL_origargv[0])) {
        while (*s) s++;

        for (i = 1; i < PL_origargc; i++) {
            if ((PL_origargv[i] == s + 1) || (aligned && (PL_origargv[i] >  s && PL_origargv[i] <= INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask))) ) {
                s = PL_origargv[i];
                while (*s) s++;
            }
            else
                break;
        }
    }

     /* Can we grab env area too to be used as the area for $0? */
    if (s && PL_origenviron && !PL_use_safe_putenv) {
        if ((PL_origenviron[0] == s + 1) || (aligned && (PL_origenviron[0] > s && PL_origenviron[0] <= INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask))) ) {
            s = PL_origenviron[0];
            while (*s) s++;
            my_setenv("NoNe  SuCh", NULL);
            /* Force copy of environment. */
            for (i = 1; PL_origenviron[i]; i++) {
                if (PL_origenviron[i] == s + 1 || (aligned && (PL_origenviron[i] >  s && PL_origenviron[i] <= INT2PTR(char *, PTR2UV(s + PTRSIZE) & mask))) ) {
                    s = PL_origenviron[i];
                    while (*s) s++;
                }
                else
                    break;
            }
        }
    }

    PL_origalen = s ? s - PL_origargv[0] + 1 : 0;
    
    /* END: Determine how long $0 is allowed to be */

    PL_main_root = NULL; /* We should really be setting PL_main_root statically */
    PL_main_start = NULL;
    PL_main_cv = NULL;

    /* $^T or $BASETIME */
    time(&PL_basetime);

    PL_dowarn = G_WARN_OFF;

    /* BEGIN eval {} */ 
    JMPENV_PUSH(ret);
    if(ret) {
        PerlIO_printf(Perl_error_log, "panic: jmpenv failed!\n");
    }
    else {
        bc_parse_body(env,xsinit);
        ret = 0;
    }
    JMPENV_POP;
    return ret;
}

void bc_parse_body(char **env, XSINIT_t xsinit)
{
    dVAR;
    int argc = PL_origargc;
    char **argv = PL_origargv;
    SV *linestr_sv = NULL;

    PERL_SET_PHASE(PERL_PHASE_START);

    /* init_main_stash(); PL_defstash setup */
    PL_curstash = PL_defstash;

    /* Set $^X early so that it can be used for relocatable paths in @INC  */
    assert (!TAINT_get);
    TAINT;
    set_caret_X();
    TAINT_NOT;

    /* init_perllib(); We hard code @INC on our own.*/

    {
        Sighandler_t sigstate = rsignal_state(SIGCHLD);
        if (sigstate == (Sighandler_t) SIG_IGN) {
            Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
                   "Can't ignore signal CHLD, forcing to default");
            (void)rsignal(SIGCHLD, (Sighandler_t)SIG_DFL);
        }
    }

    PL_main_cv = PL_compcv = MUTABLE_CV(newSV_type(SVt_PVCV));
    CvUNIQUE_on(PL_compcv);

    CvPADLIST_set(PL_compcv, pad_new(0));

    PL_isarev = newHV();

    boot_core_PerlIO();
    boot_core_UNIVERSAL();
    boot_core_mro();

    if (xsinit)
        (*xsinit)(aTHX);    /* in case linked C routines want magical variables */

    bc_init_predump_symbols();

    /* bc_init_postdump_symbols not currently designed to be called */
    /* more than once (ENV isn't cleared first, for example)     */
    /* But running with -u leaves %ENV & @ARGV undefined!    XXX */
    if (!PL_do_undump)
        bc_init_postdump_symbols(argc,argv,env);

    /* PL_unicode is turned on by -C, or by $ENV{PERL_UNICODE},
     * or explicitly in some platforms.
     * locale.c:Perl_init_i18nl10n() if the environment
     * look like the user wants to use UTF-8. */
    if (PL_unicode) {
     /* Requires init_predump_symbols(). */
        if (!(PL_unicode & PERL_UNICODE_LOCALE_FLAG) || PL_utf8locale) {
            IO* io;
            PerlIO* fp;
            SV* sv;
  
            /* Turn on UTF-8-ness on STDIN, STDOUT, STDERR
             * and the default open disciplines. */
            if ((PL_unicode & PERL_UNICODE_STDIN_FLAG)  && (io = GvIO([% IO.stdin %])) && (fp = IoIFP(io)))
                PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");
            
            if ((PL_unicode & PERL_UNICODE_STDOUT_FLAG) && (io = GvIO([% IO.stdout %])) && (fp = IoOFP(io)))
                PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");

            if ((PL_unicode & PERL_UNICODE_STDERR_FLAG) && (io = GvIO([% IO.stderr %])) && (fp = IoOFP(io)))
                PerlIO_binmode(aTHX_ fp, IoTYPE(io), 0, ":utf8");

            if ((PL_unicode & PERL_UNICODE_INOUT_FLAG) && (sv = GvSV(gv_fetchpvs("\017PEN", GV_ADD|GV_NOTQUAL, SVt_PV)))) {
                U32 in  = PL_unicode & PERL_UNICODE_IN_FLAG;
                U32 out = PL_unicode & PERL_UNICODE_OUT_FLAG;
                if (in) {
                    if (out)
                        sv_setpvs(sv, ":utf8\0:utf8");
                    else
                        sv_setpvs(sv, ":utf8\0");
                }
                else if (out)
                    sv_setpvs(sv, "\0:utf8");
                    SvSETMAGIC(sv);
            }
        }
    }

    SvREFCNT_dec(linestr_sv);

    PL_subname = newSVpvs("main");

    /* now parse the script */

    SETERRNO(0,SS_NORMAL);
    CopLINE_set(PL_curcop, 0);
    PL_defstash = PL_curstash;

    LEAVE;
    FREETMPS;

    ENTER;
    PL_restartjmpenv = NULL;
    PL_restartop = 0;
}

STATIC void bc_init_postdump_symbols(pTHX_ int argc, char **argv, char **env)
{
    /* Set PL_toptarget to a PVIV set to "" */
    PL_toptarget = newSV_type(SVt_PVIV);
    sv_setpvs(PL_toptarget, "");

    /* Set PL_bodytarget and PL_formtarget to a PVIV set to "" */
    PL_bodytarget = newSV_type(SVt_PVIV);
    sv_setpvs(PL_bodytarget, "");
    PL_formtarget = PL_bodytarget;

    TAINT;

    /* @ARGV (PL_argvgv) is setup here. */
    init_argv_symbols(argc,argv);

    PL_origfilename = savepv(argv[0]);
    sv_setpv(GvSV([% global_vars.dollar_zero %]),PL_origfilename);

    if ((PL_envgv = gv_fetchpvs("ENV", GV_ADD|GV_NOTQUAL, SVt_PVHV))) {
        HV *hv;
        bool env_is_not_environ;
        SvREFCNT_inc_simple_void_NN(PL_envgv);
        GvMULTI_on(PL_envgv);
        hv = GvHVn(PL_envgv);
        hv_magic(hv, NULL, PERL_MAGIC_env);

        /* Note that if the supplied env parameter is actually a copy
           of the global environ then it may now point to free'd memory
           if the environment has been modified since. To avoid this
           problem we treat env==NULL as meaning 'use the default'
        */
        if (!env)
            env = environ;
        env_is_not_environ = env != environ;
        if (env_is_not_environ) {
            environ[0] = NULL;
        }
        if (env) {
            char *s, *old_var;
            STRLEN nlen;
            SV *sv;
            HV *dups = newHV();

            for (; *env; env++) {
                old_var = *env;
    
                if (!(s = strchr(old_var,'=')) || s == old_var)
                    continue;
                    nlen = s - old_var;
    
                    if (hv_exists(hv, old_var, nlen)) {
                        const char *name = savepvn(old_var, nlen);
    
                        /* make sure we use the same value as getenv(), otherwise code that
                           uses getenv() (like setlocale()) might see a different value to %ENV
                         */
                        sv = newSVpv(PerlEnv_getenv(name), 0);
    
                        /* keep a count of the dups of this name so we can de-dup environ later */
                        if (hv_exists(dups, name, nlen))
                            ++SvIVX(*hv_fetch(dups, name, nlen, 0));
                        else
                            (void)hv_store(dups, name, nlen, newSViv(1), 0);
    
                        Safefree(name);
                    }
                    else
                        sv = newSVpv(s+1, 0);
                (void)hv_store(hv, old_var, nlen, sv, 0);
    
                if (env_is_not_environ)
                    mg_set(sv);
            }
              
            if (HvKEYS(dups)) {
                /* environ has some duplicate definitions, remove them */
                HE *entry;
                hv_iterinit(dups);
                while ((entry = hv_iternext_flags(dups, 0))) {
                    STRLEN nlen;
                    const char *name = HePV(entry, nlen);
                    IV count = SvIV(HeVAL(entry));
                    IV i;
                    SV **valp = hv_fetch(hv, name, nlen, 0);
    
                    assert(valp);
    
                    /* try to remove any duplicate names, depending on the
                       * implementation used in my_setenv() the iteration might
                       * not be necessary, but let's be safe.
                    */
                    for (i = 0; i < count; ++i)
                        my_setenv(name, 0);
    
                    /* and set it back to the value we set $ENV{name} to */
                    my_setenv(name, SvPV_nolen(*valp));
                }
            }

            SvREFCNT_dec_NN(dups);
        }
    }
    TAINT_NOT;

    /* touch @F array to prevent spurious warnings 20020415 MJD */
    /* B::C doesn't support perl -a so this is dead code. */
    if (PL_minus_a) {
      (void) get_av("main::F", GV_ADD | GV_ADDMULTI);
    }
}

static void bc_init_predump_symbols(pTHX)
{
    IO *io;

    sv_setpvs(get_sv("\"", GV_ADD), " ");
    PL_ofsgv = (GV*)SvREFCNT_inc(gv_fetchpvs(",", GV_ADD|GV_NOTQUAL, SVt_PV));

    /* IO::File::ISA was saved by B::C so no need to re-inject it here like init_predump_symbols() does. */

    PL_stdingv = [% IO.STDIN %];
    io = GvIOp(PL_stdingv);
    IoTYPE(io) = IoTYPE_RDONLY;
    IoIFP(io) = PerlIO_stdin();
    GvIOp([% IO.stdin %]) = MUTABLE_IO(SvREFCNT_inc_simple(io));

    io = GvIOp([% IO.STDOUT %]);
    IoTYPE(io) = IoTYPE_WRONLY;
    IoOFP(io) = IoIFP(io) = PerlIO_stdout();
    setdefout([% IO.STDOUT %]);
    GvIOp([% IO.stdout %]) = MUTABLE_IO(SvREFCNT_inc_simple(io));

    PL_stderrgv = [% IO.STDERR %];
    io = GvIOp(PL_stderrgv);
    IoTYPE(io) = IoTYPE_WRONLY;
    IoOFP(io) = IoIFP(io) = PerlIO_stderr();
    GvIOp([% IO.stderr %]) = MUTABLE_IO(SvREFCNT_inc_simple(io));

    PL_statname = newSVpvs("");        /* last filename we did stat on */
}
